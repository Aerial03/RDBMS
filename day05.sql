-- DDL(DATA DEFINITION LANGUAGE)
/*
TABLE
VIEW
SEQUENCE
INDEX

-- CONSTRAINT[PRIMARY KEY, FOREGN KEY, NOT NULL, UNIQUE, CHECK]
(기본구문)
CREATE TABLE TABLE_NAME(
    COLUMN_NAME DATATYPE [DEFAULT EXPR] [COLUMN_CONSTRAINT],
    [TABLE_CONSTRAINT]
)

-- INSERT
INSERT INTO TABLE_NAME(COLUMN) VALUES(?,?,?,?)
*/
-- DROP TABLE TEST01;
CREATE TABLE TEST01(
    ID      NUMBER(5),
    NAME    VARCHAR2(50),
    ADDRESS VARCHAR2(50),
    REGDATE DATE DEFAULT SYSDATE
);

INSERT INTO TEST01(ID, NAME, ADDRESS)
VALUES(100, '임섭순', '서울');

INSERT INTO TEST01
VALUES(100, '임섭순', '서울', NULL);

INSERT INTO TEST01
VALUES(100, '임섭순', '서울', DEFAULT);

SELECT  *
FROM    TEST01;

DROP TABLE TEST01;

-- NOT NULL
-- 테이블 레벨의 제약을 할 수 없다.

-- UNIQUE
CREATE TABLE TEST_NN(
    ID      VARCHAR(50) UNIQUE,
    PWD     VARCHAR(50)
    --  NOT NULL(ID) 불가능
);
INSERT INTO TEST_NN VALUES('JSLIM', 'JSLIM');
INSERT INTO TEST_NN VALUES(NULL, 'JSLIM');

SELECT  *
FROM    TEST_NN;

DROP TABLE TEST_NN;
-- NOT NULL과 UNIQUE를 결합하면 PRIMARY KEY가 됨

-- PRIMARY KEY: 테이블당 1개만 가능
-- NOT NULL + UNIQUE
CREATE TABLE TEST_PK(
    ID      VARCHAR2(50),
    NAME    VARCHAR2(50),
    PRIMARY KEY(ID, NAME)
);

INSERT INTO TEST_PK
VALUES('JSLIM', 'JSLIM');

INSERT INTO TEST_PK
VALUES('JSLIM', '임섭순');

SELECT *
FROM    TEST_PK;

DROP TABLE TEST_PK;

-- FOREIGN KEY, REFERENCES
-- 부모에 의존하는 데이터이거나 NULL을 허용한다.
-- DROP: 자식부터 제거해야 부모키도 제거됨
/*
DML(DELETE ~~~~)
REFERENCES [ON DELETE SET NULL] - 부모테이블만 삭제 가능, 컬럼을 NULL로 바꿈
REFERENCES [ON DELETE CASCADE] - 부모테이블만 삭제 가능, 참조하는 레코드 데이터까지 삭제
*/

CREATE TABLE LOC(
    LOCATION_ID     VARCHAR2(50) PRIMARY KEY,
    LOC_DESC        VARCHAR2(50)
);
INSERT  INTO LOC VALUES(10, '아시아');
INSERT  INTO LOC VALUES(20, '유럽');
SELECT  *
FROM    LOC;

CREATE TABLE DEPT(
    DEPT_ID     NUMBER(5) PRIMARY KEY,
    DEPT_NAME   VARCHAR2(50),
    LOC_ID      VARCHAR2(50) NOT NULL,
    FOREIGN KEY(LOC_ID) REFERENCES LOC(LOCATION_ID)
);
INSERT INTO DEPT VALUES(10, '인사팀', 10);
INSERT INTO DEPT VALUES(20, '교육팀', 20);
INSERT INTO DEPT VALUES(30, '회계팀', 20); -- NULL 넣으면 오류
SELECT  *
FROM    DEPT;

SELECT  DEPT_NAME,
        LOC_DESC
FROM    DEPT
JOIN    LOC ON(LOCATION_ID = LOC_ID);

DROP TABLE DEPT;

CREATE TABLE EMP(
    EMP_ID      VARCHAR2(50) PRIMARY KEY,
    EMP_NAME    VARCHAR2(50),
    DEPT_ID     NUMBER(5)   REFERENCES DEPT(DEPT_ID)      
);
INSERT INTO EMP VALUES('100', 'JSLIM', 10);
INSERT INTO EMP VALUES('200', 'JSLIM', NULL);
SELECT  *
FROM    EMP;
DROP TABLE EMP;

CREATE TABLE SUPER_PK(
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    O_DATE  DATE,
    AMOUNT  NUMBER,
    PRIMARY KEY(U_ID, P_ID)
);
INSERT INTO SUPER_PK VALUES('JSLIM','P100',SYSDATE, 10000);
DROP TABLE SUPER_PK CASCADE CONSTRAINTS;

CREATE TABLE SUB_PK(
    SUB_ID  VARCHAR2(20) PRIMARY KEY,
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    FOREIGN KEY(U_ID, P_ID) REFERENCES SUPER_PK(U_ID, P_ID) ON DELETE CASCADE
);

CREATE TABLE SUB_PK(
    SUB_ID  VARCHAR2(20),
    U_ID    VARCHAR2(20),
    P_ID    VARCHAR2(20),
    FOREIGN KEY(U_ID, P_ID) REFERENCES SUPER_PK(U_ID, P_ID) ON DELETE CASCADE,
    PRIMARY KEY(SUB_ID, U_ID, P_ID)
);

INSERT INTO SUB_PK VALUES('SUB100','JSLIM','P100');
SELECT  *
FROM    SUB_PK;
DROP TABLE SUB_PK;

-- CHECK
-- 조건을 정의할 때 변하는 값을 조건으로 사용할 수 없다.
CREATE TABLE TEST_CK(
    ID      VARCHAR2(50) PRIMARY KEY,
    SALARY  NUMBER,
    -- HIRE_DATE DATE CHECK(HIRE_DATE < SYSDATE),
    MARRIAGE CHAR(1),
    CHECK(SALARY BETWEEN 0 AND 100),
    CHECK(MARRIAGE IN ('Y', 'N'))
);
INSERT INTO TEST_CK VALUES('100', 100, 'Y');
SELECT  *
FROM    TEST_CK;
DROP TABLE TEST_CK;

-- DROP
-- DROP TABLE TABLE_NAME [CASCADE CONSTRAINTS] : 관계가 있는 부모테이블부터 삭제

-- VIEW
-- 테이블의 부분집합으로 보안측면이나 복잡한 쿼리를 단순화하기 위해서 사용한다.
-- 단일 뷰(입력, 삭제, 수정 가능, 원본 테이블에 반영), 복합 뷰(입력, 삭제, 수정 불가능)
-- DROP VIEW VIEW_NAME
/*
[기본구문]
CREATE [OR REPLACE] VIEW VIEW_NAME(ALIAS)
AS SUBQUERY;
*/
-- 부서번호가 90번인 사원의 이름, 부서번호만 접근할 수 있는 뷰를 생성한다면?
CREATE OR REPLACE VIEW V_EMP_90 -- (A,B)을 적어서 별칭사용 가능
AS SELECT  EMP_NAME A,
           DEPT_ID B
   FROM    EMPLOYEE
   WHERE   DEPT_ID = '90';

SELECT  *
FROM    V_EMP_90;

-- 인라인 뷰를 활용한 TOP N 분석이 가능하다.
-- 조건에 맞는 최상위 또는 최하위 레코드 N개를 식별할 때 사용
/*
분석 관리
- 정렬
- RONNUM 이라는 가상의 컬럼을 이용해서 정렬 순서대로 순번 부여
- 부여된 순번을 이용해서 필요한 수 만큼 식별
*/
SELECT  ROWNUM,
        EMP_NAME
FROM    EMPLOYEE;

SELECT  ROWNUM,
        EMP_NAME,
        SALARY
FROM    (SELECT  DEPT_ID,
                 ROUND(AVG(SALARY),-3) DAVG
         FROM    EMPLOYEE
         GROUP BY    DEPT_ID) V
JOIN    EMPLOYEE E ON(E.DEPT_ID = V.DEPT_ID)
WHERE   SALARY > V.DAVG
AND ROWNUM <= 5;

SELECT  ROWNUM, EMP_NAME, SALARY
FROM    (SELECT  ROWNUM,
                 EMP_NAME,
                 SALARY
         FROM    (SELECT  DEPT_ID,
                          ROUND(AVG(SALARY),-3) DAVG
                  FROM    EMPLOYEE
                  GROUP BY    DEPT_ID) V
         JOIN    EMPLOYEE E ON(E.DEPT_ID = V.DEPT_ID)
         WHERE   SALARY > V.DAVG
         ORDER BY 2 DESC)
WHERE ROWNUM = 1;

-- RANK()을 이용한 TOP-N 분석
SELECT  *
FROM    (SELECT  EMP_NAME,
         SALARY,
         RANK() OVER(ORDER BY SALARY DESC) RANK
         FROM    EMPLOYEE)
WHERE   RANK <= 5;

-- SEQUENCE
-- 순차적으로 정수 ㄱ밧을 자동으로 생성하는 객체
-- CREATE SEQUENCE SEQUENCE_NAME; : 1에서부터 1씩 증가, 무한대
-- NEXTVAL, CURRVAL
/*
CREAT SEQUENCE SEQUENCE_NAME
START WITH N : N에서 시작
INCREMENT BY N : N씩 증가
MAXVALUE N : 최대 N
기본적으로 CYCLE 없음
*/

CREATE SEQUENCE TEST_SEQ;
SELECT TEST_SEQ.NEXTVAL FROM DUAL;
SELECT TEST_SEQ.CURRVAL FROM DUAL;

DROP SEQUENCE TEST_SEQ;